<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <title>Google Maps Multiple Markers</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <script
        src="https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/markerclusterer.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
</head>
<style>
    body,
    html {
        height: 100%;
        width: 100%;
        padding: 0px;
        margin: 0px;
        font-family: Arial, Helvetica, sans-serif;
    }

    #map {
        width: 100%;
        height: 100%;
    }

    #container {
        display: flex;
        height: 800px;
        justify-content: space-between;
    }

    #header {
        padding: 10px;
        display: flex;
        flex-direction: row;
        align-content: center;
        align-items: center;
        justify-content: flex-start;
        background-color: #131d4b;
        color: white;
    }

    .inputs {
        padding: 5px;
    }
</style>

<body>

    <div id="main-container">
        <div id="header">
            <input id="searchTextField" class="inputs" placeholder="Enter a city, address or postal code">
        </div>
        <div id="container">
            <div id="map"></div>
        </div>

        <button id="drawSquarePoly">Draw square poly</button>
        <button id="drawMode">Draw Poly</button>
        <button id="deletePolygon">Delete Poly</button>
        <button id="saveData">Save data to DB</button>
    </div>

    <script type="text/javascript">

        let map;
        const input = document.getElementById('searchTextField');
        const drawSquarePolyButton = document.getElementById('drawSquarePoly');
        const saveDataButton = document.getElementById('saveData');
        const drawModeButton = document.getElementById('drawMode');
        const deletePolygonButton = document.getElementById('deletePolygon');
        const apiURL = 'https://serg.one/google-save-poly-api/api.php'

        let selectedShape;
        let drawingManager;
        const allShapes = [];
        let locationCenter;

        async function initMap() {

            map = new google.maps.Map(document.getElementById('map'), {
                zoom: 4,
                center: { lat: 52.31786821583068, lng: 5.511021859039191 },
                mapTypeId: google.maps.MapTypeId.ROADMAP,
                tilt: 0,
            });



            const geocoder = new google.maps.Geocoder()
            var options = {
                componentRestrictions: { country: "us" }
            };

            const autocomplete = new google.maps.places.Autocomplete(input);
            google.maps.event.addListener(autocomplete, 'place_changed', function (e) {
                var place = autocomplete.getPlace();
                const loc = place.geometry.location;
                map.setCenter(place.geometry.location);
                map.setZoom(8);
            });

            const drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: google.maps.drawing.OverlayType.POLYGON,
                drawingControl: false,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: []
                },
                polygonOptions: {
                    editable: true
                }
            });
            drawingManager.setMap(map);
            drawingManager.setDrawingMode(null);

            google.maps.event.addListener(drawingManager, 'overlaycomplete', function (e) {
                drawingManager.setDrawingMode(null);
                const newShape = e.overlay;

                newShape.setOptions({
                    clickable: true
                });
                newShape.type = e.type;
                google.maps.event.addListener(newShape, 'click', function () {
                    setSelection(newShape);
                    google.maps.event.addListener(newShape.getPath(), 'insert_at', function () {
                        console.log("allshapes index updated =", allShapes.indexOf(newShape));
                    });
                    google.maps.event.addListener(newShape.getPath(), 'set_at', function () {
                        console.log('shape coords updated', getShapeCoords(newShape));
                    });
                });
                console.log('newShape', newShape);

                allShapes.push(newShape);
                console.log("all shapes array", allShapes);
                console.log("first coords", getShapeCoords(allShapes[0]));

                //after drawing = set selected
                setSelection(newShape);
            });

            google.maps.event.addListener(drawingManager, 'drawingmode_changed', clearSelection);
            google.maps.event.addListener(map, 'click', () => { //clear selection on map click
                allShapes.forEach(d => d.setEditable(false))
                clearSelection()
            });

            drawSquarePolyButton.addEventListener('click', () => {
                const point = map.getCenter();
                const tiltedRectangle1 = createPolygonGeometry(point, 500, 500, 500, 500, 0, 4, true);
                buildPolygon(tiltedRectangle1)
            })

            saveDataButton.addEventListener('click', () => {
                saveData()
            });

            drawModeButton.addEventListener('click', () => {
                drawingManager.setDrawingMode(google.maps.drawing.OverlayType.POLYGON);
            });

            deletePolygonButton.addEventListener('click', () => {
                deleteSelectedShape();
            });

            const urlParams = getUrlVars()
            const locationUrl = urlParams.location;

            if (locationUrl) {
                geocoder.geocode({ 'address': locationUrl }, function (results, status) {
                    if (status == google.maps.GeocoderStatus.OK) {
                        locationCenter = results[0].geometry.location
                        map.setCenter(locationCenter);
                        map.setZoom(8);
                    }
                });
            }

            //------------Load Polygons from DB ----------------
            const polygons = await fetchPolygonsByID(urlParams.polygonid)
            if (polygons) {
                const bounds = new google.maps.LatLngBounds();
                polygons.geometry.map(p => {
                    const polygon = buildPolygon(p)
                    polygon.getPath().forEach(function (latLng) {
                        bounds.extend(latLng);
                    });
                })
                if (!locationCenter) map.fitBounds(bounds);
            }
            if (!polygons && !locationCenter) getUserLocation()

        }

        function buildPolygon(geometry) {
            const polygon = new google.maps.Polygon({
                paths: geometry,
                strokeColor: '#FF0000',
                strokeOpacity: 0.8,
                strokeWeight: 1,
                fillColor: '#FF0000',
                fillOpacity: 0.35,
                //editable: true,
                //draggable: true,
            });
            polygon.setMap(map);
            google.maps.event.addListener(polygon, 'click', () => {
                polygon.setEditable(true);
                selectedShape = polygon;
            });
            allShapes.push(polygon);
            return polygon;
        }

        function createPolygonGeometry(point, r1, r2, r3, r4, rotation, vertexCount, tilt) {

            var rot = -rotation * Math.PI / 180;
            var points = [];
            var latConv = google.maps.geometry.spherical.computeDistanceBetween(point, new google.maps.LatLng(point.lat() + 0.1, point.lng())) * 10;
            var lngConv = google.maps.geometry.spherical.computeDistanceBetween(point, new google.maps.LatLng(point.lat(), point.lng() + 0.1)) * 10;
            var step = (360 / vertexCount) || 10;

            var flop = -1;
            if (tilt) {
                var I1 = 180 / vertexCount;
            } else {
                var I1 = 0;
            }
            for (var i = I1; i <= 360.001 + I1; i += step) {
                var r1a = flop ? r1 : r3;
                var r2a = flop ? r2 : r4;
                flop = -1 - flop;
                var y = r1a * Math.cos(i * Math.PI / 180);
                var x = r2a * Math.sin(i * Math.PI / 180);
                var lng = (x * Math.cos(rot) - y * Math.sin(rot)) / lngConv;
                var lat = (y * Math.cos(rot) + x * Math.sin(rot)) / latConv;

                points.push(new google.maps.LatLng(point.lat() + lat, point.lng() + lng));
            }
            return points;
        }


        function getUserLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(position => {
                    console.log(position.coords.latitude, position.coords.longitude);
                    const { latitude: lat, longitude: lng } = position.coords;
                    map.panTo({ lat, lng });
                    map.setZoom(12)
                });
            }
        }

        function saveData() {
            const urlParams = getUrlVars()
            const polygonId = urlParams.polygonid || 0; //session id for saving data
            if (allShapes.length === 0) return;
            fetch(apiURL, {
                method: "POST",
                body: JSON.stringify({
                    polygonId: polygonId,
                    polygons: allShapes.map(shape => getShapeCoords(shape))
                })
            })
                .then(res => res.json())
                .then(data => {
                    console.log('data', data);
                    if (!data.id) return;
                    window.history.pushState('', '', '?polygonid=' + data.id);
                })

        }

        //make no selection
        function clearSelection() {
            if (selectedShape) {
                selectedShape.setEditable(false);
                selectedShape = null;
            }
        }
        //set selection to a shape
        function setSelection(shape) {
            clearSelection();
            selectedShape = shape;
            shape.setEditable(true);
        }
        //delete selected shape
        function deleteSelectedShape() {
            if (!selectedShape) return;
            const index = allShapes.indexOf(selectedShape);
            allShapes.splice(index, 1);
            selectedShape.setMap(null);
            console.log("allshapes after removing one", allShapes);
        }
        //get path coords
        function getShapeCoords(shape) {
            var path = shape.getPath();
            var coords = [];
            for (var i = 0; i < path.length; i++) {
                coords.push({
                    lat: path.getAt(i).lat(),
                    lng: path.getAt(i).lng()
                });
            }
            return coords;
        }

        function getUrlVars() {
            const params = new Proxy(new URLSearchParams(window.location.search), {
                get: (searchParams, prop) => searchParams.get(prop),
            });
            return params;
        }

        async function fetchPolygonsByID(polygonId) {
            if (!polygonId) return;
            return fetch(apiURL + "?id=" + polygonId)
                .then(res => res.json())
                .then(data => {
                    console.log(data);
                    return data;
                })
        }

    </script>
    <script
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB8B04MTIk7abJDVESr6SUF6f3Hgt1DPAY&callback=initMap&libraries=places,drawing,geometry&v=weekly"
        async></script>

</body>

</html>